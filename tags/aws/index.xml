<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>aws on Rosack Software Solutions</title><link>https://www.rosacksoftwaresolutions.com/tags/aws/</link><description>Recent content in aws on Rosack Software Solutions</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 26 Aug 2017 11:11:13 +0000</lastBuildDate><atom:link href="https://www.rosacksoftwaresolutions.com/tags/aws/index.xml" rel="self" type="application/rss+xml"/><item><title>Real Time Serverless Notifications with AWS IoT</title><link>https://www.rosacksoftwaresolutions.com/posts/serverless-notifications-aws-iot/</link><pubDate>Sat, 26 Aug 2017 11:11:13 +0000</pubDate><guid>https://www.rosacksoftwaresolutions.com/posts/serverless-notifications-aws-iot/</guid><description>A big downside of current &amp;ldquo;Serverless&amp;rdquo; architectures is, well, you don&amp;rsquo;t have a server! Because of this, some things that we take for granted in web applications today are hard to do in a Serverless model - take real time notifications for example. Usually you&amp;rsquo;d use SignalR, Socket.IO, or some other framework to help you set up and use websocket connections, but those frameworks require a long-lived connection to a server.</description><content>&lt;p>A big downside of current &amp;ldquo;Serverless&amp;rdquo; architectures is, well, you don&amp;rsquo;t have a server! Because of this, some things that we take for granted in web applications today are hard to do in a Serverless model - take real time notifications for example. Usually you&amp;rsquo;d use &lt;a href="https://www.asp.net/signalr">SignalR&lt;/a>, &lt;a href="https://socket.io/">Socket.IO&lt;/a>, or some other framework to help you set up and use websocket connections, but those frameworks require a long-lived connection to a server. You could use a technique like long polling in the serverless model, but serverless options charge by the second, and every second you&amp;rsquo;ve got the connection open doing nothing you&amp;rsquo;re being charged for it. So what to do?&lt;/p>
&lt;p>I had this dilemma with &lt;a href="https://www.playyourdamnturn.com/">PYDT&amp;rsquo;s&lt;/a> desktop client - it needs to know when a new turn is available for the user to play, but the only way to check for updated turns in a standard serverless model is dumb polling. Unfortunately, the cost of AWS API Gateway (which serves your requests for Lambda) is $4/million requests, so that was going to be way too expensive if we polled once a minute (46K requests a month per user, assuming a user&amp;rsquo;s PC is always on). What I originally ended up doing was caching game state to S3, and polling S3 instead of the API, which is an order of magnitude cheaper (that same $4 gets you about 10 million requests in S3).&lt;/p>
&lt;p>That worked fine, but it was hacky, and obviously websockets/push notifications were made for scenarios like this. So what do we do?&lt;/p>
&lt;p>&lt;a href="https://aws.amazon.com/iot">AWS IoT&lt;/a> to the rescue! While it&amp;rsquo;s not really designed for this purpose, it exposes an &lt;a href="http://mqtt.org/">MQTT&lt;/a> server that you can use to talk to &amp;ldquo;devices&amp;rdquo; out on the internet, but for our purposes our devices are just going to be normal web browsers. Let&amp;rsquo;s walk through the code I used to get this set up&amp;hellip;&lt;/p>
&lt;span class="disclaimer">
&lt;p>DISCLAIMER: The PYDT use case is very simple - no security is required, because no one will care if the messages we&amp;rsquo;re sending (&amp;ldquo;it&amp;rsquo;s your turn&amp;rdquo;) are intercepted by a user that wasn&amp;rsquo;t the intended receiver. Adding security complicates this scenario a lot, but this is a good example of what&amp;rsquo;s possible!&lt;/p>
&lt;/span>
&lt;p>At it&amp;rsquo;s most basic level, AWS IoT exposes an MQTT endpoint that you can use for pub/sub of messages. There&amp;rsquo;s a lot of other cool functionality in there, but for our purposes that&amp;rsquo;s all we care about. We want each user to only get messages when there&amp;rsquo;s a new turn in one of their games, but nobody else&amp;rsquo;s, so each user will need their own topic to subscribe to. In PYDT, that looks like &lt;strong>/pydt/ENVIRONMENT/user/STEAM_ID/gameupdate&lt;/strong>, where ENVIRONMENT is dev or prod, and STEAM_ID is, well, the user&amp;rsquo;s Steam ID.&lt;/p>
&lt;h2 id="client-side">Client Side&lt;/h2>
&lt;p>On the client, we&amp;rsquo;re using &lt;a href="https://github.com/aws/aws-iot-device-sdk-js">aws-iot-device-sdk-js&lt;/a>, a library that wraps an MQTT client and adds additional AWS IoT-specific functionality. It&amp;rsquo;s not too hard to set things up, here&amp;rsquo;s all the code it takes (&lt;a href="https://github.com/aws/aws-iot-device-sdk-js">starting at line 114 here&lt;/a>):&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="278914653" type="checkbox" />
&lt;label for="278914653">
&lt;span class="collapsable-code__language">javascript&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-javascript" >&lt;code>
configureIot() {
const env = PYDT_CONFIG.PROD ? &amp;#39;prod&amp;#39; : &amp;#39;dev&amp;#39;;
const topic = `/pydt/${env}/user/${this.profile.steamid}/gameupdate`;
this.iotDevice = awsIot.device({
region: &amp;#39;us-east-1&amp;#39;,
protocol: &amp;#39;wss&amp;#39;,
keepalive: 600,
accessKeyId: PYDT_CONFIG.IOT_CLIENT_ACCESS_KEY,
secretKey: PYDT_CONFIG.IOT_CLIENT_SECRET_KEY,
host: &amp;#39;a21s639tnrshxf.iot.us-east-1.amazonaws.com&amp;#39;
});
this.iotDevice.on(&amp;#39;connect&amp;#39;, () =&amp;gt; {
this.iotDevice.subscribe(topic);
});
this.iotDevice.on(&amp;#39;error&amp;#39;, err =&amp;gt; {
console.log(&amp;#39;IoT error...&amp;#39;, err);
});
this.iotDevice.on(&amp;#39;message&amp;#39;, (recTopic, message) =&amp;gt; {
console.log(&amp;#39;received message from topic &amp;#39;, recTopic);
if (recTopic === topic) {
this.loadGames();
}
});
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>A couple things to note here:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>We set the keepalive to 600 seconds. By default, I think the keepalive is 60, which means the client will ping the server once a minute to make sure the connection is open. AWS doesn&amp;rsquo;t make a big deal out of this in their documentation, but &lt;strong>YOU GET CHARGED FOR EVERY PING&lt;/strong>, and at $5/million messages that&amp;rsquo;s even worse than our dumb polling pricing! On a desktop computer, the connection should be fairly stable anyway, so only pinging once every 10 minutes isn&amp;rsquo;t that big of a deal (and I might even make that higher someday).&lt;/p>
&lt;/li>
&lt;li>
&lt;p>The access and secret keys are set up to only have permissions to subscribe to a topic and receive messages, so a malicious user wouldn&amp;rsquo;t be able to take those keys and publish messages to everyone.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>Easy, huh? That&amp;rsquo;s all it takes, and every time the server sends us a message we&amp;rsquo;ll receive it in the message callback!&lt;/p>
&lt;h2 id="server-side">Server Side&lt;/h2>
&lt;p>The server side is even easier, believe it or not. We just use the IotData class in the aws-sdk (&lt;a href="https://github.com/pydt/api/blob/00a352b0b845b8ce097290142d122458c5046817/functions/sns/userTurnNotification.js">see the userTurnNotification handler in the API&lt;/a>):&lt;/p>
&lt;div class="collapsable-code">
&lt;input id="698453721" type="checkbox" />
&lt;label for="698453721">
&lt;span class="collapsable-code__language">javascript&lt;/span>
&lt;span class="collapsable-code__toggle" data-label-expand="△" data-label-collapse="▽">&lt;/span>
&lt;/label>
&lt;pre class="language-javascript" >&lt;code>
const iotData = new AWS.IotData({endpoint: &amp;#39;a21s639tnrshxf.iot.us-east-1.amazonaws.com&amp;#39;});
function notifyUserClient(user) {
return iotData.publish({
topic: `/pydt/${process.env.SERVERLESS_STAGE}/user/${user.steamId}/gameupdate`,
payload: &amp;#34;Hello!&amp;#34;,
qos: 0
}).promise();
}
&lt;/code>&lt;/pre>
&lt;/div>
&lt;p>That&amp;rsquo;s it - all we have to do is point the client at the correct endpoint, and publish a message to the topic for the appropriate user! Notice the qos setting of 0 - that just means fire and forget. If the client is online and ready to receive the message they&amp;rsquo;ll get it, if not, no big deal, just throw the message away.&lt;/p>
&lt;h2 id="its-a-bit-anticlimactic">It&amp;rsquo;s a bit anticlimactic&amp;hellip;&lt;/h2>
&lt;p>Yeah, that&amp;rsquo;s really all it took to get push notifications working in PYDT! If you do need to authenticate the users you&amp;rsquo;re sending messages to this obviously gets quite a bit more complicated, &lt;a href="https://serverless.com/blog/serverless-notifications-on-aws/">here&amp;rsquo;s a good blog post&lt;/a> on serverless.com that describes the extra steps you&amp;rsquo;d need to do. Good luck!&lt;/p></content></item><item><title>Serverless, "Monolithic" APIs, and TSOA</title><link>https://www.rosacksoftwaresolutions.com/posts/serverless-monolithic-apis-and-tsoa/</link><pubDate>Mon, 20 Mar 2017 13:30:50 +0000</pubDate><guid>https://www.rosacksoftwaresolutions.com/posts/serverless-monolithic-apis-and-tsoa/</guid><description>I&amp;rsquo;ve been geeking out quite a bit over Functions as a Service and the Serverless Framework for the past year or so. I wrote the backend for Play Your Damn Turn using it, and I think it&amp;rsquo;s great for startup scenarios - you can write something and get it out there without having to worry about the costs of hosting, and if it suddenly becomes popular it&amp;rsquo;s already built to scale.</description><content>&lt;p>I&amp;rsquo;ve been geeking out quite a bit over Functions as a Service and the &lt;a href="https://serverless.com/">Serverless Framework&lt;/a> for the past year or so. I wrote the backend for &lt;a href="https://www.playyourdamnturn.com/">Play Your Damn Turn&lt;/a> using it, and I think it&amp;rsquo;s great for startup scenarios - you can write something and get it out there without having to worry about the costs of hosting, and if it suddenly becomes popular it&amp;rsquo;s already built to scale.&lt;/p>
&lt;p>That said, the Serverless Framework is still in it&amp;rsquo;s infancy, and there aren&amp;rsquo;t tons of best practices out there around using it. The Serverless team had a good blog post last year describing a couple possible approaches of how you could structure your application: &lt;a href="https://serverless.com/blog/serverless-architecture-code-patterns/">Serverless Code Patterns&lt;/a>. In short, that article calls out 4 different possible approaches: Microservices, where every function maps to one API call; Services/Monolithic, where you group multiple API calls into one function; and Graph, where you just expose GraphQL from one function. For PYDT, I did things Microservices style, partly because I started writing PYDT before that article was written, and partly because all of the examples out there show how you to do things the Microservices way.&lt;/p>
&lt;p>The Microservices pattern has a couple big downsides, though:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Cold Starts&lt;/strong>: When a FaaS function gets called, what&amp;rsquo;s really happening behind the scenes is a Docker container is spinning up, loading your code, and executing it. That spin up process isn&amp;rsquo;t free, and can take on the order of seconds to be ready for use. However, if you call a function multiple times in short order, the container that the code originally ran in can be reused, removing the spin up cost.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>CloudFormation Limits&lt;/strong>: Serverless uses CloudFormation behind the scenes for AWS deployments. Unfortunately, &lt;a href="http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/cloudformation-limits.html">CloudFormation has limits&lt;/a>, and there&amp;rsquo;s &lt;a href="https://github.com/serverless/serverless/issues/2853">only so many functions you can add into a Serverless service&lt;/a> before you hit these limits. I ran into this with PYDT, and I&amp;rsquo;ve had to resort to some ugly hacks to be able to fit more and more functions into the service. There&amp;rsquo;s not much they can do to fix this without getting into split CloudFormation stacks, and I think that&amp;rsquo;s pretty far down on their list at the moment.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>I&amp;rsquo;ve been kicking off a new project over the past couple of days, and because of those downsides I really didn&amp;rsquo;t want to go down the Microservices path again. Also, using Angular2 has really made me love Typescript, and I wanted to use it for the backend. If I was going to do that, couldn&amp;rsquo;t I get some cool benefits from having a strongly typed backend like auto-generation of Swagger schemas?&lt;/p>
&lt;p>Why yes, yes I could! I stumbled upon the &lt;a href="https://github.com/lukeautry/tsoa">TSOA Framework&lt;/a>, which is suprisingly the only framework I could find that&amp;rsquo;s using the benefits of Typescript to create an API backend that generates all the boilerplate for you. I forked their startup project, started playing around, and this is the result: &lt;a href="https://github.com/mrosack/tsoa-serverless-example">https://github.com/mrosack/tsoa-serverless-example&lt;/a>. It&amp;rsquo;s still super raw, but even in its initial state it&amp;rsquo;s got a lot of cool benefits over doing things the standard Javascript/Microservice way:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;strong>Automatically Generate swagger.json&lt;/strong>: This is the big carrot that TSOA waves out in front of you, and I love it. Keeping a swagger definition file up to date manually is a gigantic pain, and without eternal vigilance it can become useless pretty quickly.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>Dependency Injection&lt;/strong>: This is another thing that comes out of the box with TSOA. It uses &lt;a href="https://github.com/inversify/InversifyJS">InversifyJS&lt;/a> for it&amp;rsquo;s IOC container, and adds some sweet syntatic sugar to help hook up all the injections for you.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>No Cold Starts/Limits&lt;/strong>: The entire API is being deployed to a single Lambda function using &lt;a href="http://docs.aws.amazon.com/apigateway/latest/developerguide/api-gateway-create-api-as-simple-proxy-for-http.html">API Gateway Proxy/ANY&lt;/a>, so you don&amp;rsquo;t need to worry about cold starts for infrequently used functions or those pesky CloudFormation limits.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://github.com/mrosack/tsoa-serverless-example">Go take a look and let me know what you&amp;rsquo;ll think!&lt;/a> I&amp;rsquo;ll be updating things as I get deeper into my own project, but I think the value is pretty clear even now and I&amp;rsquo;m really excited to keep playing with it!&lt;/p></content></item></channel></rss>